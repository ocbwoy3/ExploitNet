import WebSocket from "ws";
import { BuildPlacement, ConnectedClient, MessageOrder, WSMessage, WSResponse } from "./Types";
import { InvalidAdminTokenException, InvalidBuildException, InvalidDataException, UserAlreadyLinkedException, UserNotLinkedException } from "./Exceptions";
import { BUILDS } from "./Builds";
import { GenerateBuildingRandomID } from "./Utils";
import { CFrame } from "./RobloxDatatypes";
import { getPlayerInfo } from "noblox.js";

const wss = new WebSocket.Server({
	port: 8080,
	host: "0.0.0.0"
});

let placedBuilds: BuildPlacement[] = []

async function BroadcastToAllClients(packet:WSResponse): Promise<undefined> {
	const p_json = JSON.stringify(packet)
	wss.clients.forEach((client) => {
		client.send(p_json);
	});
}

async function ProcessMessage(data: WSMessage, client: ConnectedClient): Promise<WSResponse|null> {
	if (data.LinkRobloxAccount) {
		if (client.HasLinkedRoblox == true) {
			throw new UserAlreadyLinkedException("AlreadyLinked");
		} else {
			client.HasLinkedRoblox = true;
			let userid = parseInt(data.LinkRobloxAccount.toString());
			if (isFinite(userid) == false) {
				throw new InvalidDataException("InvalidUserId")
			}
			if (isNaN(userid) == true) {
				throw new InvalidDataException("InvalidUserId")
			}
			if (userid < 1) {
				throw new InvalidDataException("InvalidUserId")
			}
			// get name
			let pinfo = await getPlayerInfo(userid)
			client.RobloxUsername = pinfo.displayName || pinfo.username
			client.RobloxUserId = userid
			return null
		};
	};
	
	if (client.HasLinkedRoblox == false) {
		throw new UserNotLinkedException("LinkRequired");
	};

	if (data.MessageOrder) {
		if ((data.MessageOrder.type || "USER") != "USER") {
			throw new InvalidAdminTokenException("NotAllowed")
		}
		let mo: MessageOrder = {
			type: data.MessageOrder.type || "USER",
			sender: client.RobloxUsername || client.RobloxUserId.toString(),
			game: data.MessageOrder.game || 0,
			content: data.MessageOrder.content.substring(0,128)
		}
		BroadcastToAllClients({
			MessageOrders: [mo]
		} as WSResponse)
	}

	if (data.Request) {
		switch (data.Request) {
			case "RequestBuilds":
				return {
					BuildingPlacement: placedBuilds
				} as WSResponse
				break;
			case "GetPresets":
				return {
					BuildLibrary: BUILDS
				} as WSResponse
				break;
			default:
				break;
		}
	}

	if (data.BuildOrder) {
		if (data.BuildOrder.Order == "DESTROY") {
			// check if the building exists
			let building = null
			placedBuilds.forEach((b:BuildPlacement)=>{
				if (b.PlacementId == data.BuildOrder.PlacementId) {
					building = b
				}
			})
			let b_index = placedBuilds.indexOf(building)
			if (b_index > -1) {
				placedBuilds.splice(b_index, 1);
			 }
		if (!building) {
			throw new InvalidBuildException("InvalidModelId");
		}
			return null;
		}

		let building_customid = data.BuildOrder.ModelId
		// check if the building exists
		let building = null
		for (let key in BUILDS) {
			let b = BUILDS[key]
			if (b.ModelId == building_customid) {
				building = b
			}
		}
		if (!building) {
			throw new InvalidBuildException("InvalidModelId");
		}
		let newBuild: BuildPlacement = {
			ModelId: building_customid,
			PlacementId: GenerateBuildingRandomID(25),
			PlacedBy: client.RobloxUserId,
			Order: "PLACE",
			CFrame: ({
				X: Math.round( data.BuildOrder.CFrame.X ),
				Y: Math.round( data.BuildOrder.CFrame.Y ),
				Z: Math.round( data.BuildOrder.CFrame.Z ),
				qX: Math.round( data.BuildOrder.CFrame.qX ),
				qY: Math.round( data.BuildOrder.CFrame.qY ),
				qZ: Math.round( data.BuildOrder.CFrame.qZ )
			} as CFrame),
			CustomData: data.BuildOrder.CustomData,
			PlaceId: 0,
			IsOnIsland: data.BuildOrder.IsOnIsland
		}
		placedBuilds.push(newBuild)
		return null;
	}

	return null;
}

wss.on('connection',async(ws: WebSocket, request)=>{
	const C_REMOTE_ADDR = `${ request.headers['x-forwarded-for'] || request.socket.remoteAddress || "invalidaddress" }:${ request.socket.remotePort || "0" }`;
	console.log(`[ExploitNet/WSServer] Client Connected: ${C_REMOTE_ADDR}`);
	
	let client: ConnectedClient = {
		RobloxUserId: null,
		RobloxUsername: null,
		HasLinkedRoblox: false,
		IsExploitNetAdmin: false,
		AdminKey: null,
		IPAddress: C_REMOTE_ADDR
	}

	ws.on('message',async(message: string)=>{
		console.log(`[ExploitNet/WSServer] [ ${C_REMOTE_ADDR} ] ${message}`);

		try {
			let jsd: WSMessage = JSON.parse(message);
			let d: WSResponse = await ProcessMessage(jsd,client);
			console.log(d);
			if (d) {
				ws.send(JSON.stringify(d));
			}
		} catch (_e: any) {
			var e: Error = (_e as Error);
			ws.send(JSON.stringify({
				error: `${e.message}`
			}));
		}

	})

	ws.on('close', async() => {
		console.log(`[ExploitNet/WSServer] Client Disconnected: ${C_REMOTE_ADDR}`);
	});

})

console.log("[ExploitNet] Server loaded.")